<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lavigne-yang.Blob | Lavigne-yang.Blob</title><meta name="author" content="Lavigne-yang"><meta name="copyright" content="Lavigne-yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="业务场景Q：topK 问题 给定 100 个 int 数字，在其中找出最大的 10 个；  给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字可以无序）；  给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字依次排序）；  给定 10 亿个不重复的 int 数字，在其中找出最大的 10 个；  给定 10 个数组，每个数组中有 1 亿个 int">
<meta property="og:type" content="article">
<meta property="og:title" content="Lavigne-yang.Blob">
<meta property="og:url" content="https://lavigne-yang.github.io/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/index.html">
<meta property="og:site_name" content="Lavigne-yang.Blob">
<meta property="og:description" content="业务场景Q：topK 问题 给定 100 个 int 数字，在其中找出最大的 10 个；  给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字可以无序）；  给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字依次排序）；  给定 10 亿个不重复的 int 数字，在其中找出最大的 10 个；  给定 10 个数组，每个数组中有 1 亿个 int">
<meta property="og:locale">
<meta property="og:image" content="https://lavigne-yang.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-05-28T08:55:23.289Z">
<meta property="article:modified_time" content="2025-05-28T00:54:26.000Z">
<meta property="article:author" content="Lavigne-yang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lavigne-yang.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://lavigne-yang.github.io/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/",
  "image": "https://lavigne-yang.github.io/img/butterfly-icon.png",
  "datePublished": "2025-05-28T08:55:23.289Z",
  "dateModified": "2025-05-28T00:54:26.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lavigne-yang",
      "url": "https://lavigne-yang.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lavigne-yang.github.io/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lavigne-yang.Blob',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lavigne-yang.Blob</span></a><a class="nav-page-title" href="/"><span class="site-name">Lavigne-yang.Blob</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-28T08:55:23.289Z" title="Created 2025-05-28 16:55:23">2025-05-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-28T00:54:26.000Z" title="Updated 2025-05-28 08:54:26">2025-05-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><h3 id="Q：topK-问题"><a href="#Q：topK-问题" class="headerlink" title="Q：topK 问题"></a><strong>Q：topK 问题</strong></h3><ol>
<li><p>给定 100 个 int 数字，在其中找出最大的 10 个；</p>
</li>
<li><p>给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字可以无序）；</p>
</li>
<li><p>给定 10 亿个 int 数字，在其中找出最大的 10 个（这 10 个数字依次排序）；</p>
</li>
<li><p>给定 10 亿个不重复的 int 数字，在其中找出最大的 10 个；</p>
</li>
<li><p>给定 10 个数组，每个数组中有 1 亿个 int 数字，在其中找出最大的 10 个；</p>
</li>
<li><p>给定 10 亿个 string 类型的数字，在其中找出最大的 10 个（仅需要查 1 次）；</p>
</li>
<li><p>给定 10 亿个 string 类型的数字，在其中找出最大的 k 个（需要反复多次查询，其中 k 是一个随机数字）。</p>
</li>
<li><p><strong>堆排序法</strong></p>
<p> 堆排序法（<code>PriorityQueue</code> ），而不是快排或者希尔排序。虽然理论时间复杂度都是 <code>O(nlogn)</code>，但是堆排在做 topK 的时候有一个优势，就是可以维护一个仅包含 k 个数字的小顶堆（想清楚，为啥是小顶堆哦），当新加入的数字大于堆顶数字的时候，将堆顶元素剔除，并加入新的数字</p>
</li>
<li><p> <strong>类似快排法</strong></p>
<p> 仅对部分数据进行递归计算。比如，在 100 个数字中，找最大的 10 个，第一次循环的时候，povit 被移动到了 80 的位置，则接下来仅需要在后面的 20 个数字中找最大的 10 个即可。理论最优时间复杂度可以达到 <code>O(n)</code>，不过平均时间复杂度还是 <code>O(nlogn)</code>。需要说明的是，通过这种方式，找出来的最大的 k 个数字之间，是无序的</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> begin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="type">int</span> <span class="variable">povit</span> <span class="operator">=</span> arr[begin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= povit) &#123;right--;&#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= povit) &#123;left++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;swap(arr[left], arr[right]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr[begin], arr[left]);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">partSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">povit</span> <span class="operator">=</span> partition(arr, begin, end);</span><br><span class="line">    <span class="keyword">if</span> (target &lt; povit) &#123;</span><br><span class="line">        partSort(arr, begin, povit - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; povit) &#123;</span><br><span class="line">        partSort(arr, povit + <span class="number">1</span>, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="title function_">getMaxNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>)arr.size();</span><br><span class="line">    <span class="comment">// 把求最大的k个数，转换成求最小的size-k个数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> size - k;</span><br><span class="line">    partSort(arr, <span class="number">0</span>, size - <span class="number">1</span>, target);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="title function_">ret</span><span class="params">(arr.end()</span> - k, arr.end());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">ret</span> <span class="operator">=</span> getMaxNumbers(vec, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (auto x : ret) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;    <span class="comment">// 输出7，8，9（理论上无序）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 bitmap</strong></p>
<p> 有时候 topK 问题会遇到数据量过大，内存无法全部加载。这个时候，可以考虑将数据存放至 bitmap 中，方便查询。</p>
<p> 比如，给出 10 个 int 类型的数据，分别是【13，12，11，1，2，3，4，5，6，7】，int 类型的数据每个占据 4 个字节，那这个数组就占据了 40 个字节。现在，把它们放到一个 16 个长度 bool 的 bitmap 中，结果就是【0，1，1，1，1，1，1，1，0，0，0，1，1，1，0，0】，在将空间占用降低至 4 字节的同时，也可以很方便的看出，最大的 3 个数字，分别是 11，12 和 13。</p>
<p> 需要说明的是，bitmap 结合跳表一起使用往往有奇效。比如以上数据还可以记录成：从第 1 位开始，有连续 7 个 1；从第 11 位开始，有连续 3 个 1。这样做，空间复杂度又得到了进一步的降低。</p>
<p> 这种做法的优势，当然是降低了空间复杂度。不过需要注意一点，bitmap 比较适合不重复且有范围（比如，数据均在 0 ～ 10 亿之间）的数据的查询。至于有重复数据的情况，可以考虑与 hash 等结构的混用。</p>
</li>
<li><p><strong>使用 hash</strong></p>
<p> 如果遇到了查询 string 类型数据的大小，可以考虑 hash 方法。</p>
<p> 举个例子，10 个 string 数字【”1001”，”23”，”1002”，”3003”，”2001”，”1111”，”65”，”834”，”5”，”987”】找最大的 3 个。我们先通过长度进行 hash，得到长度最大为 4，且有 5 个长度为 4 的 string。接下来再通过最高位值做 hash，发现有 1 个最高位为”3”的，1 个为”2”的，3 个为”1”的。接下来，可以通过再设计 hash 函数，或者是循环的方式，在 3 个最高位为”1”的 string 中找到最大的一个，即可找到 3 个最值大的数据。</p>
<p> 这种方法比较适合网址或者电话号码的查询。缺点就是如果需要多次查询的话，需要多次计算 hash，并且需要根据实际情况设计多个 hash 函数</p>
</li>
<li><p><strong>字典树</strong></p>
<p> 字典树（trie）的具体结构和查询方式，不在这里赘述了，自行百度一下就有很多。这里主要说一下优缺点。</p>
<p> 字典树的思想，还是通过前期建立索引信息，后期可以反复多次查询，并且后期增删数据也很方便。比较适合于需要反复多次查询的情况。</p>
<p> 比如，反复多次查询字符序（例如：z&gt;y&gt;…&gt;b&gt;a）最大的 k 个 url 这种，使用字典树把数据存储一遍，就非常适合。既减少了空间复杂度，也加速了查询效率</p>
</li>
<li><p><strong>混合查询</strong></p>
<p> 以上几种方法，都是比较独立的方法。其实，在实际工作中，遇到更多的问题还是混合问题，这就需要我们对相关的内容，融会贯通并且做到活学活用。</p>
<p> 我举个例子：我们的分布式服务跑在 10 台不同机器上，每台机器上部署的服务均被请求 10000 次，并且记录了个这 10000 次请求的耗时（耗时值为 int 数据），找出这 10*10000 次请求中，从高到低的找出耗时最大的 50 个。看看这个问题，很现实吧。我们试着用上面介绍的方法，组合一下来求解。</p>
<p> <strong>方法一</strong></p>
<p> 首先，对每台机器上的 10000 个做类似快排，找出每台机器上 top50 的耗时信息。此时，单机上的这 50 条数据是无序的。</p>
<p> 然后，再将 10 台机器上的 50 条数据（共 500 条）放到一起，再做一次类似快排，找到最大的 50 个（此时应该这 50 个应该是无序的）。</p>
<p> 最后，对这 50 个数据做快排，从而得到最终结果。</p>
<p> <strong>方法二</strong></p>
<p> 首先通过堆排，分别找出 10 台机器上耗时最高的 50 个数据，此时的这 50 个数据，已经是从大到小有序的了。</p>
<p> 然后，我们依次取出 10 台机器中，耗时最高的 5 条放入小顶堆中。</p>
<p> 最后，遍历 10 台机器上的数据，每台机器从第 6 个数据开始往下循环，如果这个值比堆顶的数据大，则抛掉堆顶数据并且把它加入，继续用下一个值进行同样比较。如果这个值比堆顶的值小，则结束当前循环，并且在下一台机器上做同样操作。</p>
<p> 以上我介绍了两种方法，并不是为了说明哪种方法更好，或者时间复杂度更低。而是想说同样的事情有多种不同的解决方法，而且随着数据量的增加，可能会需要更多组合形式。在这个领域，数据决定了数据结构，数据结构决定了算法。</p>
</li>
</ol>
<h3 id="Q：Redis和数据库的缓存一致性保证"><a href="#Q：Redis和数据库的缓存一致性保证" class="headerlink" title="Q：Redis和数据库的缓存一致性保证"></a><strong>Q：Redis和数据库的缓存一致性保证</strong></h3><p>A： 方案如下：</p>
<ol>
<li><p>更新数据库之后删除缓存（<strong>旁路缓存模式</strong>）</p>
<p> 并发情况下可采用<strong>延迟双删策略</strong></p>
<p> 或者实现canal客户端订阅数据变更，更新缓存</p>
<p> 适合：商品详情页场景，读多写少的场景</p>
</li>
<li><p>先更新缓存再更新数据库（<strong>异步更新</strong>）</p>
<ol>
<li>更新缓存成功采用消息队列更新数据（消费幂等性保证）</li>
<li>场景：秒杀</li>
</ol>
</li>
<li><p>双写操作</p>
<ol>
<li>同时更新Redis和数据库，可以使用事务保证（分布式事务方案，<strong>事务补偿机制</strong>）</li>
<li>场景：积分</li>
</ol>
</li>
<li><p>数据回写</p>
<ol>
<li>优先更新缓存，缓存数据定期更新到数据库（Redis集群和持久化机制）</li>
<li>场景：广告计费系统，点赞</li>
</ol>
</li>
</ol>
<h3 id="Q：分布式锁实现方案"><a href="#Q：分布式锁实现方案" class="headerlink" title="Q：分布式锁实现方案"></a>Q：分布式锁实现方案</h3><p>A：</p>
<ol>
<li>本地同步锁</li>
<li>分布式锁setNX 设置超时时间</li>
<li>redission看门狗机制，读写锁</li>
<li>redisssion redlock 解决锁的高一致性问题</li>
</ol>
<h3 id="Q：如何快速定位线上OOM"><a href="#Q：如何快速定位线上OOM" class="headerlink" title="Q：如何快速定位线上OOM"></a>Q：如何快速定位线上OOM</h3><p>A：<strong>出现的原因：</strong></p>
<ol>
<li>一次性申请的对象数量过多：如查询返回结果过大</li>
<li>内存资源耗尽未释放：如何jdbc连接、文件资源</li>
<li>本身资源不够：<code>jmap -heap PID</code> 查看堆信息</li>
</ol>
<p><strong>方案：</strong></p>
<ol>
<li>预先设置<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_logs</code> 参数保证发生OOM时有堆信息输出</li>
<li>导出dump文件 <code>jmap -dump:format=b,file=xushu.hprof PID</code></li>
</ol>
<p>结合jvisualvm和idea进行查看，找过GCRooot 查看线程栈线程</p>
<h3 id="Q：如何定位和避免死锁"><a href="#Q：如何定位和避免死锁" class="headerlink" title="Q：如何定位和避免死锁"></a>Q：如何定位和避免死锁</h3><p>A：</p>
<p>定位：</p>
<ol>
<li><code>jstack PID</code></li>
<li>业务日志</li>
</ol>
<p>方案</p>
<ol>
<li>破坏产生死锁的四大因素之一（除互斥）</li>
<li>银行家算法也能有效避免【预先计算分配资源】</li>
</ol>
<h3 id="Q：SpringBoot或Tomcat可以同时处理的最大请求数"><a href="#Q：SpringBoot或Tomcat可以同时处理的最大请求数" class="headerlink" title="Q：SpringBoot或Tomcat可以同时处理的最大请求数"></a>Q：SpringBoot或Tomcat可以同时处理的最大请求数</h3><p>A：accept-count + max-connections</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">12600</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">200</span></span><br><span class="line">      <span class="attr">min-spare:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 最大等待数 当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">100</span></span><br><span class="line">    <span class="comment"># 最大连接数 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以根据“acceptCount”属性接受连接</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">8192</span></span><br><span class="line">    <span class="comment"># 连接超时时间</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<h3 id="Q：Sentinel限流算法"><a href="#Q：Sentinel限流算法" class="headerlink" title="Q：Sentinel限流算法"></a>Q：Sentinel限流算法</h3><p>A：</p>
<ol>
<li><p><strong>滑动窗口计数法（Sliding Window Counting）</strong></p>
<p> <strong>核心思想</strong>：将时间划分为多个小的时间窗口（如 500ms），统计每个窗口内的请求数量，并动态滑动窗口，避免固定窗口的“突刺问题”。</p>
<ol>
<li><strong>固定窗口计数法</strong>：将时间划分为固定大小的窗口（如 1s），统计窗口内的请求总数。缺点是可能出现“突刺”（例如前 1ms 内请求过多，后 999ms 被拒绝）</li>
<li><strong>滑动窗口计数法</strong>：通过多个子窗口（如 20 个 50ms 的子窗口）动态统计流量，避免突刺问题。例如，Sentinel 默认使用 1s 的窗口，划分为 2 个 500ms 的子窗口。</li>
<li><strong>优点</strong>：<ol>
<li>避免固定窗口的突刺问题，流量统计更平滑。</li>
<li>适用于 QPS 限流、热点参数限流等场景。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>令牌桶算法（Token Bucket）</strong></p>
<p> <strong>核心思想</strong>：以固定速率生成令牌，存入令牌桶。请求必须获取令牌才能被处理。如果令牌桶满，多余令牌被丢弃；如果令牌桶空，请求被拒绝或等待</p>
<p> **Sentinel 实现：**令牌桶算法：允许突发流量（桶容量决定突发流量大小）。预热模式（Warm Up）：通过令牌桶的动态调整，实现系统冷启动时的流量预热。例如，从低阈值逐渐增加到设定阈值。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarmUpController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> count; <span class="comment">// 最大 QPS 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> warmUpPeriodInSec; <span class="comment">// 预热时间（秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> coldFactor; <span class="comment">// 冷却因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> warningToken; <span class="comment">// 警戒令牌数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> maxToken; <span class="comment">// 最大令牌数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> slope; <span class="comment">// 斜率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(<span class="type">int</span> acquireCount)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTokens</span> <span class="operator">=</span> storedTokens.get(); <span class="comment">// 当前令牌数</span></span><br><span class="line">        <span class="keyword">if</span> (currentTokens &gt;= warningToken) &#123;</span><br><span class="line">            <span class="comment">// 超过警戒线，按预热公式计算允许的 QPS</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">allowedQps</span> <span class="operator">=</span> <span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count);</span><br><span class="line">            <span class="keyword">return</span> passQps + acquireCount &lt;= allowedQps;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 正常模式，按令牌桶算法处理</span></span><br><span class="line">            <span class="keyword">return</span> passQps + acquireCount &lt;= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>优点</strong>：<ul>
<li>支持突发流量（令牌桶容量决定）。</li>
<li>预热模式避免冷启动时系统被压垮。</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>漏桶算法（Leaky Bucket）</strong></p>
<p> <strong>核心思想</strong>：请求进入漏桶后，以<strong>固定速率</strong>处理。如果漏桶满，新请求被拒绝或排队等待。</p>
<p> **Sentinel 实现：**排队等待模式（RateLimiter）：允许请求排队等待，直到令牌桶有空间。例如，设置最大等待时间，超时则拒绝。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxQueueingTimeMs; <span class="comment">// 最大等待时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> count; <span class="comment">// QPS 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">latestPassedTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(<span class="type">int</span> acquireCount)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> Math.round(<span class="number">1.0</span> * acquireCount / count * <span class="number">1000</span>); <span class="comment">// 计算间隔时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedTime</span> <span class="operator">=</span> costTime + latestPassedTime.get();</span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 立即通过</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> expectedTime - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (waitTime &lt;= maxQueueingTimeMs) &#123;</span><br><span class="line">                Thread.sleep(waitTime); <span class="comment">// 等待</span></span><br><span class="line">                latestPassedTime.set(currentTime + waitTime);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超时拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优点</strong>：<ul>
<li>严格限制流量速率，适合对延迟敏感的场景（如数据库访问）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>快速失败模式（DefaultController）</strong></p>
<p> 基于滑动窗口统计 QPS，如果当前 QPS 超过阈值，直接拒绝请求。</p>
</li>
</ol>
<h3 id="Q：SpringBoot如何优化启动速度"><a href="#Q：SpringBoot如何优化启动速度" class="headerlink" title="Q：SpringBoot如何优化启动速度"></a>Q：SpringBoot如何优化启动速度</h3><p>A：</p>
<ul>
<li>延迟初始化Bean：懒加载，或异步执行初始化任务</li>
<li>创建扫描索引，引入index依赖 <code>@Indexed索引</code>，编译打包时Spring在项目自动生成META-INF&#x2F;spring.componets文件维护索引，Spring应用启动时会执行ComponentScan扫描时，这个文件将会被CandidateComponentsIndexLoader读取并加载，转为CandidateComponentsIndex对象；</li>
<li>去除不必要的自动配置和扫描范围</li>
<li>关闭Spring Boot的JMX监控 <code>spring.jmx.enabled=false</code></li>
<li>JVM参数关闭类验证</li>
<li>AOP尽量不使用注解方式标记，会对所有方法进行扫描</li>
<li>排除不需要的依赖</li>
<li>JDK17 新的特性支持更好的垃圾回收期，SpringBoot3的GraalVM支持编译成本地镜像文件，启动速度更快，内存占用更少</li>
</ul>
<h3 id="Q：SqlSessionFactory（线程安全）和SqlSession（不安全）是线程安全的吗"><a href="#Q：SqlSessionFactory（线程安全）和SqlSession（不安全）是线程安全的吗" class="headerlink" title="Q：SqlSessionFactory（线程安全）和SqlSession（不安全）是线程安全的吗"></a>Q：SqlSessionFactory（线程安全）和SqlSession（不安全）是线程安全的吗</h3><p>A：判断一个类是否是线程安全的</p>
<ul>
<li>是否有共享的可变状态</li>
<li>是否使用了线程安全的数据结构</li>
<li>是否使用了同步机制</li>
<li>如果类中的共享资源是不可变的</li>
</ul>
<aside>
💡

<p>Spring通过动态代理机制实现了<strong>SqlSession</strong>线程安全，若没有标记<code>@Transactional</code>注解，spring在方法级别每一次调用都是新建一个sqlSession，否则通过ThreadLocalMap保证一个线程对应一个SqlSession</p>
</aside>

<h3 id="Q：如何解决线程CPU飙高"><a href="#Q：如何解决线程CPU飙高" class="headerlink" title="Q：如何解决线程CPU飙高"></a>Q：如何解决线程CPU飙高</h3><p>A：</p>
<ol>
<li><code>top</code>命令查询CPU占用最高的<strong>进程</strong></li>
<li><code>top -H -p PID</code> 找到CPU占用最高的<strong>线程</strong></li>
<li><code>printf  ‘0x%x\n’ PID</code> 将线程ID转为16进制</li>
<li><code>jstack 进程PID | grep 16进制线程PID -A 20</code> 找到进程中指定线程执行的状态和代码</li>
</ol>
<h3 id="Q：布隆过滤器解决缓存穿透的原理"><a href="#Q：布隆过滤器解决缓存穿透的原理" class="headerlink" title="Q：布隆过滤器解决缓存穿透的原理"></a>Q：布隆过滤器解决缓存穿透的原理</h3><p>A：Redis实现布隆过滤器功能  setbit   bitmap原理</p>
<p><strong>误判几率：</strong></p>
<p>延迟位数长度  </p>
<p>增加hash法的个数</p>
<h3 id="Q：内存200M读取1G文件，统计文件内容"><a href="#Q：内存200M读取1G文件，统计文件内容" class="headerlink" title="Q：内存200M读取1G文件，统计文件内容"></a>Q：内存200M读取1G文件，统计文件内容</h3><p>A：</p>
<ul>
<li>使用缓冲区分块读取 map缓存次数，如果存在大量不重复的情况  可考虑使用hash取模存储到多个文件中，逐个读取细分的文件综合统计</li>
</ul>
<h3 id="Q：new-String-“abc”-会创建几个对象"><a href="#Q：new-String-“abc”-会创建几个对象" class="headerlink" title="Q：new String(“abc”)会创建几个对象"></a>Q：<strong>new String(“abc”)会创建几个对象</strong></h3><p>A：两个对象</p>
<ol>
<li>new String() 预先创建一个对象引用，然后判断常量池中是否存在，创建常量池对象。然后拿到常量池对象初始化预先创建的对象引用</li>
<li>String s &#x3D; “abc” 直接在常量池中创建对象</li>
</ol>
<h3 id="Q：百万计数据插入优化"><a href="#Q：百万计数据插入优化" class="headerlink" title="Q：百万计数据插入优化"></a>Q：百万计数据插入优化</h3><p>A：</p>
<p>方案：多线程分批导入，线程池 IO密集型  cpu空闲时间长  可以将线程数据设置 （核心线程数&#x3D;cpu个数 * 2， 最大线程数 &#x3D; cpu个数 * 4）</p>
<h3 id="Q：单表多少数据量需要分表"><a href="#Q：单表多少数据量需要分表" class="headerlink" title="Q：单表多少数据量需要分表"></a>Q：单表多少数据量需要分表</h3><p>A：阿里巴巴推荐：一般来说推荐单表行数超过500万行或者单表容量超过2G，推荐进行分表；（如果三年内数据量达不到这个级别，创建时不建议进行分表）</p>
<p><strong>分析：</strong> B+树索引由一页一页数据（16KB）组成，结构如下 , 所以有效的数据空间  <strong><code>16384 -200 = 16184字节</code></strong></p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>中文名</strong></th>
<th><strong>占用空间大小</strong></th>
<th><strong>简单描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页完整性</td>
</tr>
</tbody></table>
<p>所以一般来说：<strong>所有磁盘页的数量 * 一页的数据行数  （数据行数 &#x3D; 有效页大小 &#x2F; 一行设计数据大小 ） &#x3D;&#x3D; 三层的B+树的总数据量</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Lavigne-yang.github.io">Lavigne-yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lavigne-yang.github.io/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/">https://lavigne-yang.github.io/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/28/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lavigne-yang</div><div class="author-info-description">dawdawd</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">业务场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9AtopK-%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text">Q：topK 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9ARedis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">Q：Redis和数据库的缓存一致性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.0.3.</span> <span class="toc-text">Q：分布式锁实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%BA%BF%E4%B8%8AOOM"><span class="toc-number">1.0.4.</span> <span class="toc-text">Q：如何快速定位线上OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.5.</span> <span class="toc-text">Q：如何定位和避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9ASpringBoot%E6%88%96Tomcat%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E5%A4%A7%E8%AF%B7%E6%B1%82%E6%95%B0"><span class="toc-number">1.0.6.</span> <span class="toc-text">Q：SpringBoot或Tomcat可以同时处理的最大请求数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9ASentinel%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.7.</span> <span class="toc-text">Q：Sentinel限流算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9ASpringBoot%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">1.0.8.</span> <span class="toc-text">Q：SpringBoot如何优化启动速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9ASqlSessionFactory%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89%E5%92%8CSqlSession%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">1.0.9.</span> <span class="toc-text">Q：SqlSessionFactory（线程安全）和SqlSession（不安全）是线程安全的吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8BCPU%E9%A3%99%E9%AB%98"><span class="toc-number">1.0.10.</span> <span class="toc-text">Q：如何解决线程CPU飙高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.11.</span> <span class="toc-text">Q：布隆过滤器解决缓存穿透的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%86%85%E5%AD%98200M%E8%AF%BB%E5%8F%961G%E6%96%87%E4%BB%B6%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">1.0.12.</span> <span class="toc-text">Q：内存200M读取1G文件，统计文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9Anew-String-%E2%80%9Cabc%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.13.</span> <span class="toc-text">Q：new String(“abc”)会创建几个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E7%99%BE%E4%B8%87%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.14.</span> <span class="toc-text">Q：百万计数据插入优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q%EF%BC%9A%E5%8D%95%E8%A1%A8%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%E9%87%8F%E9%9C%80%E8%A6%81%E5%88%86%E8%A1%A8"><span class="toc-number">1.0.15.</span> <span class="toc-text">Q：单表多少数据量需要分表</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" title="Untitled">Untitled</a><time datetime="2025-05-28T08:55:23.289Z" title="Created 2025-05-28 16:55:23">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/hello-world/" title="Hello World">Hello World</a><time datetime="2025-05-28T08:33:36.242Z" title="Created 2025-05-28 16:33:36">2025-05-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Lavigne-yang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>